<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>BASE OMEGA // Nivel 1</title>
<style>
  html, body {
    margin: 0;
    background: #000;
    color: #fff;
    font-family: system-ui, sans-serif;
    overflow: hidden;
  }

  #gameCanvas {
    display: block;
    width: 100vw;
    height: 100vh;
    background: #000;
  }

  /* UI overlay */
  #ui {
    position: fixed;
    left: 0;
    top: 0;
    width: 100vw;
    color: #fff;
    padding: 8px 12px;
    font-size: 12px;
    line-height: 1.4;
    user-select: none;
    pointer-events: none;
    text-shadow: 0 0 4px #000;
    font-family: monospace;
  }

  #centerText {
    position: fixed;
    top: 50%;
    left: 50%;
    translate: -50% -50%;
    color: rgba(255,255,255,0.8);
    font-family: monospace;
    font-size: 14px;
    text-align: center;
    text-shadow: 0 0 4px #000;
    user-select: none;
    pointer-events: none;
    white-space: pre-line;
    max-width: 80vw;
  }

  #crosshair {
    position: fixed;
    left: 50%;
    top: 50%;
    width: 16px;
    height: 16px;
    translate: -50% -50%;
    pointer-events: none;
    user-select: none;
  }
  #crosshair:before,
  #crosshair:after {
    content: '';
    position: absolute;
    background: rgba(255,255,255,0.8);
  }
  /* vertical line */
  #crosshair:before {
    left: 50%;
    top: 0;
    width: 2px;
    height: 100%;
    translate: -50% 0;
  }
  /* horizontal line */
  #crosshair:after {
    top: 50%;
    left: 0;
    height: 2px;
    width: 100%;
    translate: 0 -50%;
  }

  #startOverlay {
    position: fixed;
    inset: 0;
    background: radial-gradient(circle at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.9) 70%);
    display: grid;
    place-items: center;
    color: #fff;
    font-family: system-ui, sans-serif;
    text-align: center;
    padding: 24px;
    cursor: crosshair;
  }

  #startOverlay button {
    background: #8b0000;
    border: 0;
    padding: 12px 20px;
    border-radius: 8px;
    color: #fff;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    box-shadow: 0 10px 30px rgba(255,0,0,0.4);
  }
  #startOverlay button:hover {
    background: #b10000;
  }

  /* mobile hint hidden on desktop */
  @media (min-width: 768px) {
    .mobile-hint { display: none; }
  }

  #bigMessage {
    position: fixed;
    bottom: 16px;
    left: 50%;
    translate: -50% 0;
    background: rgba(0,0,0,0.6);
    padding: 6px 10px;
    border-radius: 6px;
    font-family: monospace;
    font-size: 12px;
    color: #fff;
    text-shadow: 0 0 4px #000;
    pointer-events: none;
    min-width: 200px;
    text-align: center;
  }

  #winOverlay, #deadOverlay {
    position: fixed;
    inset: 0;
    display: none;
    background: radial-gradient(circle at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.95) 70%);
    place-items: center;
    font-family: monospace;
    text-align: center;
    color: #fff;
    padding: 24px;
    line-height: 1.4;
  }
  #winOverlay h2,
  #deadOverlay h2 {
    margin: 0 0 12px;
    font-size: 20px;
    letter-spacing: -0.03em;
    color: #f33;
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="800" height="450"></canvas>

<div id="ui">
  <div><b>WASD</b> moverse · <b>Mouse</b> mirar · <b>Click</b> disparar</div>
  <div>BASE OMEGA — NIVEL 1: "FUGA"</div>
  <div id="debug"></div>
</div>

<div id="centerText"></div>
<div id="crosshair"></div>
<div id="bigMessage"></div>

<div id="startOverlay">
  <div style="max-width:380px;">
    <h1 style="margin:0 0 12px;font-size:20px;letter-spacing:-0.03em;font-weight:700;font-family:monospace;">
      BASE OMEGA<br>PROTOTIPO FPS
    </h1>
    <p style="margin:0 0 16px;font-size:13px;line-height:1.4;color:#ccc;font-family:monospace;white-space:pre-line;">
      Despiertas en la Base Omega, un complejo industrial subterráneo.
      Algo salió mal. Puertas selladas. Sirenas apagadas.
      Personal desaparecido.

      Objetivo:
      1) Encuentra la TARJETA ROJA en el Laboratorio Biocontención.
      2) Llega al HANGAR DE EVACUACIÓN y escapa.

      Si ves a los guardias mutados... dispara primero.
    </p>
    <button id="startBtn">INICIAR</button>
    <p class="mobile-hint" style="margin-top:12px;color:#f66;font-size:12px;">
      Este demo está pensado para teclado + mouse (PC).
    </p>
  </div>
</div>

<div id="winOverlay">
  <div>
    <h2>ESCAPASTE</h2>
    <p style="font-size:14px;color:#ccc;white-space:pre-line;">
      Subes a la cápsula de evacuación.
      La Base Omega queda atrás ardiendo.

      Nivel completado.
    </p>
  </div>
</div>

<div id="deadOverlay">
  <div>
    <h2>ESTÁS MUERTO</h2>
    <p style="font-size:14px;color:#ccc;white-space:pre-line;">
      Tu señal vital se apagó en los pasillos de la Base Omega.

      Recarga la página para intentarlo de nuevo.
    </p>
  </div>
</div>

<script>
/*
  ============================
  CONFIGURACIÓN DEL MOTOR
  ============================
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const debugEl = document.getElementById('debug');
const startOverlay = document.getElementById('startOverlay');
const startBtn = document.getElementById('startBtn');
const centerText = document.getElementById('centerText');
const bigMessage = document.getElementById('bigMessage');
const winOverlay = document.getElementById('winOverlay');
const deadOverlay = document.getElementById('deadOverlay');

/*
  ============================
  MAPA GRANDE
  ============================
  0 = piso libre
  1 = muro
  2 = salida/hangar de evacuación (zona final)
  3 = laboratorio (tarjeta roja spawnea aquí como item)
  4 = decorativo muro grueso (visualmente mismo color, pero podemos usar otro tono)
*/
const worldMap = [
  // 40x40 aprox, tipo base con corredores, zona inicial, lab, hangar
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,1,4,4,4,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,1,4,3,3,3,4,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,1,4,3,3,3,4,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,1,4,4,4,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],

  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],

  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],

  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],

  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];
const mapWidth  = worldMap[0].length;
const mapHeight = worldMap.length;

/*
  ============================
  JUGADOR
  ============================
*/
let px = 2.5;   // spawn zona inicial
let py = 2.5;
let pAngle = 0;

const FOV = Math.PI / 3; // ~60°
const moveSpeed = 3.0;   // unidades/seg
const rotSpeed = 2.5;    // rad/seg

let mouseLocked = false;

const keys = {
  w:false,a:false,s:false,d:false,left:false,right:false
};

// Vida y combate
let playerHP = 100;
const playerMaxHP = 100;
let regenCooldown = 0; // tiempo hasta empezar a regenerar
let hasRedKey = false;
let alive = true;
let levelWon = false;

// disparo
let shooting = false;
let shootCooldown = 0.0;

/*
  ============================
  ENEMIGOS (IA básica)
  ============================
  state: 'patrol' o 'chase'
  patrolPoints: array de puntos que recorre
  patrolIndex: índice actual
  touchDamageTimer: cd para hacer daño cuerpo a cuerpo
*/
const enemies = [
  {
    x:10.5, y:5.5, alive:true,
    state:'patrol',
    patrolPoints:[{x:10.5,y:5.5},{x:14.5,y:5.5},{x:14.5,y:8.5},{x:10.5,y:8.5}],
    patrolIndex:0,
    touchDamageTimer:0
  },
  {
    x:20.5, y:12.5, alive:true,
    state:'patrol',
    patrolPoints:[{x:20.5,y:12.5},{x:25.5,y:12.5},{x:25.5,y:15.5},{x:20.5,y:15.5}],
    patrolIndex:0,
    touchDamageTimer:0
  },
  {
    x:32.5, y:25.5, alive:true,
    state:'patrol',
    patrolPoints:[{x:32.5,y:25.5},{x:35.5,y:25.5},{x:35.5,y:28.5},{x:32.5,y:28.5}],
    patrolIndex:0,
    touchDamageTimer:0
  }
];

/*
  ============================
  ITEMS
  ============================
  type: 'medkit' o 'redkey'
*/
const items = [
  {x:11.5,y:6.5,type:'medkit',taken:false},
  {x:24.5,y:13.5,type:'medkit',taken:false},
  {x:12.5,y:7.5,type:'redkey',taken:false}, // Tarjeta roja en laboratorio (zona 3)
];

/*
  ============================
  INPUT
  ============================
*/
document.addEventListener('keydown', e=>{
  switch(e.code){
    case 'KeyW': keys.w=true; break;
    case 'KeyA': keys.a=true; break;
    case 'KeyS': keys.s=true; break;
    case 'KeyD': keys.d=true; break;
    case 'ArrowLeft': keys.left=true; break;
    case 'ArrowRight': keys.right=true; break;
  }
});
document.addEventListener('keyup', e=>{
  switch(e.code){
    case 'KeyW': keys.w=false; break;
    case 'KeyA': keys.a=false; break;
    case 'KeyS': keys.s=false; break;
    case 'KeyD': keys.d=false; break;
    case 'ArrowLeft': keys.left=false; break;
    case 'ArrowRight': keys.right=false; break;
  }
});

function lockPointer() {
  canvas.requestPointerLock = canvas.requestPointerLock ||
                              canvas.mozRequestPointerLock;
  canvas.requestPointerLock();
}
document.addEventListener('pointerlockchange', ()=>{
  mouseLocked = (document.pointerLockElement === canvas);
  if(mouseLocked){
    centerText.textContent = "";
  } else {
    if(!levelWon && alive){
      centerText.textContent = "Click para capturar mouse";
    }
  }
});
document.addEventListener('mousemove', e=>{
  if(mouseLocked){
    const sensitivity = 0.0025;
    pAngle += e.movementX * sensitivity;
  }
});

canvas.addEventListener('mousedown', e=>{
  if(!alive || levelWon) return;
  if(mouseLocked && shootCooldown<=0){
    shooting = true;
    shootCooldown = 0.25;
    tryHitEnemy();
  } else {
    if(!mouseLocked){ lockPointer(); }
  }
});

/*
  ============================
  MOVIMIENTO DEL JUGADOR
  ============================
*/
function canWalk(nx, ny){
  if(nx<0||ny<0||nx>=mapWidth||ny>=mapHeight) return false;
  const cell = worldMap[Math.floor(ny)][Math.floor(nx)];
  if(cell===1||cell===4) return false; // muros sólidos
  return true;
}

function tryMove(nx, ny){
  if(canWalk(nx,ny)){
    px = nx;
    py = ny;
  }
}

function updatePlayer(dt){
  // rotación con flechas
  if(keys.left)  pAngle -= rotSpeed*dt;
  if(keys.right) pAngle += rotSpeed*dt;

  const forwardX = Math.cos(pAngle);
  const forwardY = Math.sin(pAngle);
  const rightX = Math.cos(pAngle + Math.PI/2);
  const rightY = Math.sin(pAngle + Math.PI/2);

  let movX = 0;
  let movY = 0;

  if(keys.w){ movX += forwardX; movY += forwardY; }
  if(keys.s){ movX -= forwardX; movY -= forwardY; }
  if(keys.a){ movX -= rightX;   movY -= rightY;   }
  if(keys.d){ movX += rightX;   movY += rightY;   }

  const len = Math.hypot(movX,movY);
  if(len>0){
    movX/=len; movY/=len;
    const nx = px + movX * moveSpeed * dt;
    const ny = py + movY * moveSpeed * dt;
    tryMove(nx, ny);
  }
}

/*
  ============================
  RAYCASTING
  ============================
*/
function castRay(rayAngle){
  const rayDirX = Math.cos(rayAngle);
  const rayDirY = Math.sin(rayAngle);

  let mapX = Math.floor(px);
  let mapY = Math.floor(py);

  const deltaDistX = (rayDirX === 0) ? 1e30 : Math.abs(1 / rayDirX);
  const deltaDistY = (rayDirY === 0) ? 1e30 : Math.abs(1 / rayDirY);

  let stepX, sideDistX;
  let stepY, sideDistY;

  if(rayDirX < 0){
    stepX = -1;
    sideDistX = (px - mapX) * deltaDistX;
  } else {
    stepX = 1;
    sideDistX = (mapX + 1.0 - px) * deltaDistX;
  }
  if(rayDirY < 0){
    stepY = -1;
    sideDistY = (py - mapY) * deltaDistY;
  } else {
    stepY = 1;
    sideDistY = (mapY + 1.0 - py) * deltaDistY;
  }

  let hit = 0;
  let side = 0;
  let tile = 0;

  while(hit === 0){
    if(sideDistX < sideDistY){
      sideDistX += deltaDistX;
      mapX += stepX;
      side = 0;
    } else {
      sideDistY += deltaDistY;
      mapY += stepY;
      side = 1;
    }
    if(mapX<0||mapX>=mapWidth||mapY<0||mapY>=mapHeight) { hit=1; break; }
    tile = worldMap[mapY][mapX];
    if(tile === 1 || tile === 4){
      hit = 1;
    } else if(tile === 2){
      // salida no bloquea rayos (puerta abierta físicamente),
      // la tratamos como espacio vacío en lo visual
    } else if(tile === 3){
      // laboratorio paredes interiores están rodeadas por 4 (muro grueso),
      // pero el 3 es "sala" accesible, no lo bloqueamos.
    }
  }

  let perpWallDist;
  if(side===0){ perpWallDist = (sideDistX - deltaDistX); }
  else        { perpWallDist = (sideDistY - deltaDistY); }

  return {dist: perpWallDist, side, tile};
}

function renderWorld(){
  const w = canvas.width;
  const h = canvas.height;

  // Cielo
  const skyGradient = ctx.createLinearGradient(0,0,0,h/2);
  skyGradient.addColorStop(0,"#222");
  skyGradient.addColorStop(1,"#000022");
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0,0,w,h/2);

  // Piso
  const floorGradient = ctx.createLinearGradient(0,h/2,0,h);
  floorGradient.addColorStop(0,"#1a1a1a");
  floorGradient.addColorStop(1,"#000000");
  ctx.fillStyle = floorGradient;
  ctx.fillRect(0,h/2,w,h/2);

  for(let x=0;x<w;x++){
    const cameraX = (2*x/w - 1);
    const rayAngle = pAngle + Math.atan(cameraX * Math.tan(FOV/2));
    const ray = castRay(rayAngle);
    const dist = ray.dist;
    const lineH = Math.floor(h / dist);

    let drawStart = -lineH/2 + h/2;
    let drawEnd   =  lineH/2 + h/2;
    if(drawStart < 0) drawStart = 0;
    if(drawEnd >= h)  drawEnd = h-1;

    // colores pared segun tipo
    let fillCol = "#884444"; // default muro
    if(ray.tile===4){ fillCol="#663333"; }
    // sombrear lado
    if(ray.side===1){
      // más oscuro
      fillCol = shadeColor(fillCol, -40);
    }

    if(ray.tile===1 || ray.tile===4){
      ctx.fillStyle = fillCol;
      ctx.fillRect(x, drawStart, 1, drawEnd-drawStart);
    } else {
      // Si no chocó muro (salida/lab/aire libre),
      // dibujamos nada (solo cielo/piso)
    }
  }
}

/* util para sombrear color hex sencillo tipo #rrggbb */
function shadeColor(col, amt){
  // col "#rrggbb"
  const r = parseInt(col.slice(1,3),16);
  const g = parseInt(col.slice(3,5),16);
  const b = parseInt(col.slice(5,7),16);
  function clamp(v){ return Math.max(0,Math.min(255,v)); }
  const R = clamp(r+amt);
  const G = clamp(g+amt);
  const B = clamp(b+amt);
  return "#"+R.toString(16).padStart(2,'0')+
             G.toString(16).padStart(2,'0')+
             B.toString(16).padStart(2,'0');
}

/*
  ============================
  SPRITES (enemigos e ítems)
  ============================
*/

function losClear(aX,aY,bX,bY){
  // línea de visión: casteo ray hacia b y comparo dist
  const ang = Math.atan2(bY-aY,bX-aX);
  const dx = bX-aX;
  const dy = bY-aY;
  const dTarget = Math.hypot(dx,dy);
  // casteo "desde el origen" aproximando con px/py global? mejor temporal:
  const backupPX=px, backupPY=py;
  px=aX; py=aY;
  const r = castRay(ang);
  px=backupPX; py=backupPY;
  return (r.dist+0.05 >= dTarget);
}

function updateEnemies(dt){
  for(const e of enemies){
    if(!e.alive) continue;

    // detección jugador
    const distToPlayer = Math.hypot(e.x-px,e.y-py);
    const seePlayer = (distToPlayer < 6 && losClear(e.x,e.y,px,py));

    if(seePlayer){
      e.state='chase';
    }

    if(e.state==='patrol'){
      const target = e.patrolPoints[e.patrolIndex];
      const ddx = target.x - e.x;
      const ddy = target.y - e.y;
      const d = Math.hypot(ddx,ddy);
      if(d<0.1){
        e.patrolIndex = (e.patrolIndex+1)%e.patrolPoints.length;
      } else {
        // intenta moverse hacia el punto de patrulla
        const stepX = ddx/d * 1.5*dt;
        const stepY = ddy/d * 1.5*dt;
        moveEnemy(e, e.x+stepX, e.y+stepY);
      }
    } else if(e.state==='chase'){
      // moverse hacia jugador
      const ddx = px - e.x;
      const ddy = py - e.y;
      const d = Math.hypot(ddx,ddy);
      if(d>0.05){
        const stepX = ddx/d * 2.2*dt;
        const stepY = ddy/d * 2.2*dt;
        moveEnemy(e, e.x+stepX, e.y+stepY);
      }

      // daño cuerpo a cuerpo si está muy cerca
      if(d<1.2){
        if(e.touchDamageTimer<=0){
          damagePlayer(12);
          e.touchDamageTimer=1.0; // 1s cd
        }
      }
    }

    // bajar cd de daño
    if(e.touchDamageTimer>0){
      e.touchDamageTimer -= dt;
      if(e.touchDamageTimer<0)e.touchDamageTimer=0;
    }
  }
}

function moveEnemy(e,nx,ny){
  if(canWalk(nx,ny)){
    e.x=nx;
    e.y=ny;
  }
}

function renderSprites(){
  const w = canvas.width;
  const h = canvas.height;

  // enemigos + items en un solo array para ordenar por distancia
  const sprites = [];

  for(const e of enemies){
    if(!e.alive) continue;
    sprites.push({
      kind:'enemy',
      x:e.x,y:e.y,
      dist:Math.hypot(e.x-px,e.y-py)
    });
  }

  for(const it of items){
    if(it.taken) continue;
    sprites.push({
      kind:it.type,
      x:it.x,y:it.y,
      dist:Math.hypot(it.x-px,it.y-py)
    });
  }

  // dibujar lejos->cerca
  sprites.sort((a,b)=>b.dist-a.dist);

  for(const s of sprites){
    const dx = s.x - px;
    const dy = s.y - py;
    const angleTo = Math.atan2(dy,dx);
    let angleDiff = angleTo - pAngle;
    while(angleDiff<-Math.PI) angleDiff+=2*Math.PI;
    while(angleDiff> Math.PI) angleDiff-=2*Math.PI;
    if(Math.abs(angleDiff)>FOV) continue;

    const dist = Math.hypot(dx,dy);
    if(dist<0.2) continue;

    // depth check LOS contra paredes
    const backupPX=px, backupPY=py;
    px=backupPX; py=backupPY; // not moving actually, just clarity
    const r = castRay(angleTo);
    if(r.dist < dist-0.05) continue; // bloqueado por pared

    const screenX = (0.5 + (angleDiff/(FOV))) * w;
    const spriteH = (h / dist) * 0.7;
    const spriteW = spriteH * 0.6;
    const drawX = screenX - spriteW/2;
    const drawY = h/2 - spriteH/2;

    if(s.kind==='enemy'){
      ctx.fillStyle = "#aa0000";
      ctx.fillRect(drawX, drawY, spriteW, spriteH);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.strokeRect(drawX, drawY, spriteW, spriteH);
      // cara amarilla
      ctx.fillStyle = "#ffff99";
      ctx.fillRect(drawX+spriteW*0.3, drawY+spriteH*0.2, spriteW*0.4, spriteH*0.25);
    } else if(s.kind==='medkit'){
      ctx.fillStyle = "#00aa00";
      ctx.fillRect(drawX, drawY, spriteW*0.7, spriteH*0.7);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(drawX+spriteW*0.22, drawY+spriteH*0.32, spriteW*0.26, spriteH*0.06);
      ctx.fillRect(drawX+spriteW*0.31, drawY+spriteH*0.23, spriteW*0.06, spriteH*0.26);
    } else if(s.kind==='redkey'){
      ctx.fillStyle = "#ff0000";
      ctx.fillRect(drawX, drawY, spriteW*0.5, spriteH*0.5);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.strokeRect(drawX, drawY, spriteW*0.5, spriteH*0.5);
    }
  }
}

/*
  ============================
  COMBATE / DISPARO
  ============================
*/
function tryHitEnemy(){
  const aimTolerance = 0.05;
  let best=null;
  for(const e of enemies){
    if(!e.alive) continue;
    const dx=e.x-px;
    const dy=e.y-py;
    const ang=Math.atan2(dy,dx);
    let diff=ang-pAngle;
    while(diff<-Math.PI) diff+=2*Math.PI;
    while(diff> Math.PI) diff-=2*Math.PI;
    if(Math.abs(diff)<aimTolerance){
      const d=Math.hypot(dx,dy);
      const r=castRay(ang);
      if(r.dist+0.01>=d){
        if(!best || d<best.d) best={enemy:e,d};
      }
    }
  }
  if(best){
    best.enemy.alive=false;
    flashHit();
  } else {
    flashMiss();
  }
}

function damagePlayer(amount){
  if(!alive) return;
  playerHP -= amount;
  regenCooldown = 3.0; // reinicia cooldown de regen
  if(playerHP<=0){
    playerHP=0;
    alive=false;
    deadOverlay.style.display='grid';
    centerText.textContent = "";
  }
}

function pickupItems(){
  for(const it of items){
    if(it.taken) continue;
    const d = Math.hypot(it.x-px,it.y-py);
    if(d<1.0){
      if(it.type==='medkit'){
        // cura
        playerHP = Math.min(playerMaxHP, playerHP+40);
        showBigMessage("Botiquín recogido (+40 HP)");
        it.taken=true;
      } else if(it.type==='redkey'){
        hasRedKey=true;
        showBigMessage("Tarjeta Roja obtenida.\nDirígete al Hangar de Evacuación.");
        it.taken=true;
      }
    }
  }
}

/*
  ============================
  EFECTOS VISUALES HUD
  ============================
*/
let flashTimer = 0;
let flashColor = "rgba(255,255,255,0.4)";
function flashHit(){
  flashColor = "rgba(0,255,0,0.4)";
  flashTimer = 0.08;
}
function flashMiss(){
  flashColor = "rgba(255,0,0,0.4)";
  flashTimer = 0.08;
}

function renderGun(dt){
  const w = canvas.width;
  const h = canvas.height;
  const gunW = w*0.25;
  const gunH = h*0.35;
  let recoilY = shooting ? 10 : 0;
  const x = w*0.5 - gunW*0.5;
  const y = h - gunH + recoilY;

  ctx.fillStyle = "#444";
  ctx.fillRect(x, y, gunW, gunH);

  ctx.fillStyle = "#777";
  ctx.fillRect(x+gunW*0.1, y+gunH*0.4, gunW*0.8, gunH*0.5);

  ctx.fillStyle = "#222";
  ctx.fillRect(x+gunW*0.4, y+gunH*0.1, gunW*0.2, gunH*0.3);
}

function renderFlash(dt){
  if(flashTimer>0){
    ctx.fillStyle = flashColor;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    flashTimer -= dt;
    if(flashTimer<0) flashTimer=0;
  }
}

/*
  ============================
  HUD / MENSAJES
  ============================
*/
let bigMessageTimer = 0;
function showBigMessage(msg){
  bigMessage.textContent = msg;
  bigMessageTimer = 3.0;
}

function updateBigMessage(dt){
  if(bigMessageTimer>0){
    bigMessageTimer -= dt;
    if(bigMessageTimer<=0){
      bigMessage.textContent = "";
      bigMessageTimer=0;
    }
  }
}

function renderHUD(){
  debugEl.textContent =
    `HP:${playerHP.toFixed(0)}/${playerMaxHP}  `+
    `Tarjeta:${hasRedKey?"ROJA":"-" }  `+
    `Objetivo: ${levelWon?"ESCAPASTE": alive?"Consigue la Tarjeta Roja y llega al Hangar":"MUERTO"}\n`+
    `x:${px.toFixed(2)} y:${py.toFixed(2)} ang:${pAngle.toFixed(2)}`;
}

/*
  ============================
  VICTORIA
  ============================
*/
function checkWinCondition(){
  if(!alive || levelWon) return;
  const cell = worldMap[Math.floor(py)][Math.floor(px)];
  // cell==2 es hangar de evacuación / salida
  if(cell===2){
    if(hasRedKey){
      levelWon=true;
      winOverlay.style.display='grid';
      centerText.textContent = "";
      showBigMessage("Base Omega evacuada. Nivel completado.");
    } else {
      showBigMessage("Puerta sellada.\nNecesitas la Tarjeta Roja.");
    }
  }
}

/*
  ============================
  UPDATE GENERAL
  ============================
*/
function update(dt){
  if(!alive || levelWon) return;

  // player
  updatePlayer(dt);

  // cooldown de disparo
  if(shootCooldown>0){
    shootCooldown -= dt;
    if(shootCooldown<0){
      shootCooldown=0;
      shooting=false;
    }
  }

  // regeneración de vida lenta
  if(regenCooldown>0){
    regenCooldown-=dt;
  } else {
    if(playerHP>0 && playerHP<playerMaxHP){
      playerHP += 4*dt; // ~4 HP/s lenta
      if(playerHP>playerMaxHP) playerHP=playerMaxHP;
    }
  }

  // enemigos
  updateEnemies(dt);

  // recoger ítems
  pickupItems();

  // check victoria
  checkWinCondition();

  // mensajes HUD temporales
  updateBigMessage(dt);
}

/*
  ============================
  RENDER GENERAL
  ============================
*/
function render(dt){
  renderWorld();
  renderSprites();
  renderGun(dt);
  renderFlash(dt);
  renderHUD();
}

/*
  ============================
  LOOP PRINCIPAL
  ============================
*/
let lastT = performance.now();
function gameLoop(now){
  const dt = (now-lastT)/1000;
  lastT = now;

  update(dt);
  render(dt);

  requestAnimationFrame(gameLoop);
}

/*
  ============================
  START
  ============================
*/
startBtn.addEventListener('click', ()=>{
  startOverlay.style.display='none';
  if(!levelWon && alive){
    centerText.textContent = "Click para capturar mouse";
  }
  lockPointer();
  lastT = performance.now();
  requestAnimationFrame(gameLoop);
});

</script>
</body>
</html>
