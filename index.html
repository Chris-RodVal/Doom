<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>FPS DEMO Optimizado - Laboratorio Nivel 1</title>
<style>
  html, body {
    margin: 0;
    background: #000;
    color: #fff;
    font-family: system-ui, sans-serif;
    overflow: hidden;
  }

  #view {
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    width: 100vw;
    height: 100vh;
    display: block;
    background: #000;
  }

  #ui {
    position: fixed;
    left: 0;
    top: 0;
    width: 100vw;
    color: #fff;
    padding: 8px 12px;
    font-size: 12px;
    line-height: 1.4;
    user-select: none;
    pointer-events: none;
    text-shadow: 0 0 4px #000;
    font-family: monospace;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  #statsRow {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
  }

  #healthBarContainer {
    width: 140px;
    height: 12px;
    background: rgba(0,0,0,0.6);
    border: 1px solid #400;
    border-radius: 3px;
    position: relative;
  }
  #healthBarFill {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    background: linear-gradient(#a00,#600);
    border-radius: 2px;
    width: 100%;
  }
  #healthText {
    font-size: 11px;
    line-height: 1;
    text-shadow: 0 0 4px #000;
    margin-left: 4px;
  }

  #missionText {
    max-width: 400px;
    font-size: 11px;
    line-height: 1.4;
    color: #ccc;
    text-shadow: 0 0 4px #000;
  }

  #debug {
    font-size: 10px;
    color: #666;
  }

  #crosshair {
    position: fixed;
    left: 50%;
    top: 50%;
    width: 16px;
    height: 16px;
    translate: -50% -50%;
    pointer-events: none;
    user-select: none;
  }
  #crosshair:before,
  #crosshair:after {
    content: '';
    position: absolute;
    background: rgba(255,255,255,0.8);
  }
  #crosshair:before {
    left: 50%;
    top: 0;
    width: 2px;
    height: 100%;
    translate: -50% 0;
  }
  #crosshair:after {
    top: 50%;
    left: 0;
    height: 2px;
    width: 100%;
    translate: 0 -50%;
  }

  #centerText {
    position: fixed;
    top: 50%;
    left: 50%;
    translate: -50% -50%;
    color: rgba(255,255,255,0.8);
    font-family: monospace;
    font-size: 14px;
    text-align: center;
    text-shadow: 0 0 4px #000;
    user-select: none;
    pointer-events: none;
    white-space: pre-line;
  }

  #startOverlay {
    position: fixed;
    inset: 0;
    background: radial-gradient(circle at center,
      rgba(0,0,0,0.4) 0%,
      rgba(0,0,0,0.9) 70%);
    display: grid;
    place-items: center;
    color: #fff;
    font-family: system-ui, sans-serif;
    text-align: center;
    padding: 24px;
    cursor: crosshair;
  }

  #startOverlay button {
    background: #8b0000;
    border: 0;
    padding: 12px 20px;
    border-radius: 8px;
    color: #fff;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    box-shadow: 0 10px 30px rgba(255,0,0,0.4);
  }

  #startOverlay button:hover {
    background: #b10000;
  }

  @media (min-width: 768px) {
    .mobile-hint { display: none; }
  }
</style>
</head>
<body>

<!-- Render interno baja resoluci√≥n -->
<canvas id="internal" width="320" height="180" style="display:none;"></canvas>
<!-- Vista escalada full pantalla -->
<canvas id="view"></canvas>

<div id="ui">
  <div id="statsRow">
    <div style="display:flex;align-items:center;gap:4px;">
      <div id="healthBarContainer"><div id="healthBarFill"></div></div>
      <div id="healthText">VIDA 100/100</div>
    </div>
    <div style="font-size:11px;color:#aaa;text-shadow:0 0 4px #000;">
      WASD moverse ¬∑ Mouse mirar ¬∑ Click disparar
    </div>
  </div>

  <div id="missionText">
    NIVEL 1 ¬∑ Laboratorio Abandonado<br>
    Objetivo: Recupera el <b>N√öCLEO ROJO</b> y llega a la PUERTA DE EXTRACCI√ìN.
  </div>

  <div id="debug"></div>
</div>

<div id="crosshair"></div>
<div id="centerText"></div>

<div id="startOverlay">
  <div style="max-width:340px;">
    <h1 style="margin:0 0 12px;font-size:20px;letter-spacing:-0.03em;font-weight:700;font-family:monospace;">
      NIVEL 1: LABORATORIO ABANDONADO
    </h1>
    <p style="margin:0 0 16px;font-size:14px;line-height:1.4;color:#ccc;font-family:monospace;">
      La instalaci√≥n colaps√≥ tras el experimento del N√∫cleo Rojo.<br><br>
      Tarea:<br>
      1) Encuentra el N√∫cleo Rojo.<br>
      2) Sobrevive a la seguridad humana corrompida.<br>
      3) Llega a la puerta de extracci√≥n.<br><br>
      Haz click en INICIAR y acepta capturar el mouse.
    </p>
    <button id="startBtn">INICIAR</button>
    <p class="mobile-hint" style="margin-top:12px;color:#f66;font-size:12px;">
      Este demo est√° pensado para teclado + mouse (PC).
    </p>
  </div>
</div>

<script>
/* ============================
   CANVAS SETUP
============================ */
const lowCanvas = document.getElementById('internal');
const lowCtx = lowCanvas.getContext('2d');
const viewCanvas = document.getElementById('view');
const viewCtx = viewCanvas.getContext('2d');

function resizeView() {
  viewCanvas.width = window.innerWidth;
  viewCanvas.height = window.innerHeight;
}
resizeView();
window.addEventListener('resize', resizeView);

/* ============================
   DOM refs
============================ */
const centerText = document.getElementById('centerText');
const startOverlay = document.getElementById('startOverlay');
const startBtn = document.getElementById('startBtn');
const missionTextEl = document.getElementById('missionText');
const debugEl = document.getElementById('debug');
const healthBarFill = document.getElementById('healthBarFill');
const healthText = document.getElementById('healthText');

let mouseLocked = false;

/* ============================
   MAPA
============================ */
const worldMap = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,2,2,2,0,0,0,0,0,0,0,3,3,3,0,0,0,0,1],
  [1,0,2,0,2,0,0,0,0,0,0,0,3,0,3,0,0,0,0,1],
  [1,0,2,2,2,0,0,0,0,0,0,0,3,3,3,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];
const mapW = worldMap[0].length;
const mapH = worldMap.length;

/* ============================
   PLAYER
============================ */
let px = 2.5;
let py = 2.5;
let pAngle = 0;

const FOV = Math.PI/3;
const moveSpeed = 3.0;
const rotSpeed = 2.5;

let playerHP = 100;
const playerMaxHP = 100;
const regenPerSec = 2;

let shooting = false;
let shootCooldown = 0;

let hasCore = false;
let levelFinished = false;

/* ============================
   INPUT ESTADO
============================ */
const keys = { w:false, a:false, s:false, d:false, left:false, right:false };

// üî• FIX PRINCIPAL AQU√ç:
// - Escuchamos en window (no solo document)
// - Hacemos preventDefault() para WASD y flechas
//   para que el browser no ‚Äúrobe‚Äù la tecla.
function handleKey(e, isDown){
  // c√≥digo f√≠sico de la tecla, independiente de layout
  // (en teclado espa√±ol igual es 'KeyW', 'KeyA', etc.)
  const code = e.code;

  if (code === "KeyW") { keys.w = isDown; e.preventDefault(); }
  if (code === "KeyA") { keys.a = isDown; e.preventDefault(); }
  if (code === "KeyS") { keys.s = isDown; e.preventDefault(); }
  if (code === "KeyD") { keys.d = isDown; e.preventDefault(); }

  if (code === "ArrowLeft")  { keys.left  = isDown; e.preventDefault(); }
  if (code === "ArrowRight") { keys.right = isDown; e.preventDefault(); }
}

window.addEventListener('keydown', e => handleKey(e, true), {passive:false});
window.addEventListener('keyup',   e => handleKey(e, false), {passive:false});

// Pointer lock + mouse look
function lockPointer(){
  viewCanvas.requestPointerLock = viewCanvas.requestPointerLock || viewCanvas.mozRequestPointerLock;
  viewCanvas.requestPointerLock();
}
document.addEventListener('pointerlockchange', ()=>{
  mouseLocked = (document.pointerLockElement === viewCanvas);
  centerText.textContent = mouseLocked ? "" : "Click para capturar mouse";
});
document.addEventListener('mousemove', e=>{
  if(mouseLocked){
    const sensitivity = 0.0025;
    pAngle += e.movementX * sensitivity;
  }
});
viewCanvas.addEventListener('mousedown', ()=>{
  if(mouseLocked){
    if(shootCooldown<=0){
      shooting = true;
      shootCooldown = 0.25;
      shootEnemy();
    }
  } else {
    lockPointer();
  }
});

/* ============================
   TEXTURAS PAREDES
============================ */
function makeWallTexture(patternFn){
  const c = document.createElement('canvas');
  c.width = 64; c.height = 64;
  const cx = c.getContext('2d');
  const imgData = cx.createImageData(64,64);
  const d = imgData.data;
  for(let y=0;y<64;y++){
    for(let x=0;x<64;x++){
      const idx=(y*64+x)*4;
      const col=patternFn(x,y);
      d[idx+0]=col.r;
      d[idx+1]=col.g;
      d[idx+2]=col.b;
      d[idx+3]=255;
    }
  }
  cx.putImageData(imgData,0,0);
  return c;
}
const wallTex1 = makeWallTexture((x,y)=>{
  const stripe=(x%16<2||y%16<2)?80:0;
  return {r:150+stripe,g:20+stripe*0.2,b:20+stripe*0.2};
});
const wallTex2 = makeWallTexture((x,y)=>{
  const grid=((x%8===0)||(y%8===0))?200:140;
  return {r:grid,g:grid,b:grid+10};
});
const wallTex3 = makeWallTexture((x,y)=>{
  const noise=((x*y)%13)*10;
  const baseG=180+(noise%40);
  return {r:20,g:baseG,b:20};
});
const wallTex4 = makeWallTexture((x,y)=>{
  const stripe = (((x+y)%16)<8);
  if(stripe){ return {r:230,g:210,b:40}; }
  return {r:30,g:30,b:30};
});
const wallTextures = {1:wallTex1,2:wallTex2,3:wallTex3,4:wallTex4};

/* ============================
   ENEMIGOS HUMANOS con IA
============================ */
function makeHumanSprite(skin, suit){
  const c = document.createElement('canvas');
  c.width=24; c.height=40;
  const cx=c.getContext('2d');

  // Piernas
  cx.fillStyle=suit;
  cx.fillRect(8,28,8,12);

  // Torso
  cx.fillStyle=suit;
  cx.fillRect(4,14,16,16);

  // Brazos
  cx.fillStyle=skin;
  cx.fillRect(0,16,4,12);
  cx.fillRect(20,16,4,12);

  // Cabeza
  cx.fillStyle=skin;
  cx.fillRect(7,4,10,10);

  // Ojos
  cx.fillStyle="#000";
  cx.fillRect(9,8,2,2);
  cx.fillRect(13,8,2,2);

  // Contorno
  cx.strokeStyle="#000";
  cx.lineWidth=2;
  cx.strokeRect(4,14,16,16);
  cx.strokeRect(7,4,10,10);
  return c;
}

const ENEMY_ARCHETYPE = {
  speed: 1.5,
  dmgPerSec: 15,
  range: 1.3,
  maxHP: 60,
  textureIdle: makeHumanSprite("#ffe0c0","#444"),
  textureWalk: makeHumanSprite("#ffe0c0","#666")
};

const enemies = [
  {x:6.5,y:3.5,hp:60,alive:true,walkPhase:0},
  {x:12.5,y:2.5,hp:60,alive:true,walkPhase:0},
  {x:14.5,y:3.5,hp:60,alive:true,walkPhase:0},
  {x:10.5,y:14.5,hp:60,alive:true,walkPhase:0},
  {x:16.5,y:16.0,hp:60,alive:true,walkPhase:0},
];

/* ============================
   PICKUPS
============================ */
function makeMedkitTexture(){
  const c=document.createElement('canvas');
  c.width=20; c.height=20;
  const cx=c.getContext('2d');
  cx.fillStyle="#fff";
  cx.fillRect(0,0,20,20);
  cx.fillStyle="#c00";
  cx.fillRect(8,2,4,16);
  cx.fillRect(2,8,16,4);
  cx.strokeStyle="#000";
  cx.lineWidth=2;
  cx.strokeRect(0,0,20,20);
  return c;
}
function makeCoreTexture(){
  const c=document.createElement('canvas');
  c.width=20;c.height=20;
  const cx=c.getContext('2d');
  cx.fillStyle="#400";
  cx.fillRect(0,0,20,20);
  cx.fillStyle="#f00";
  cx.beginPath();
  cx.arc(10,10,6,0,Math.PI*2);
  cx.fill();
  cx.strokeStyle="#000";
  cx.lineWidth=2;
  cx.strokeRect(0,0,20,20);
  cx.strokeStyle="#900";
  cx.lineWidth=2;
  cx.stroke();
  return c;
}

const medkitTex = makeMedkitTexture();
const coreTex   = makeCoreTexture();

const pickups = [
  {x:4.5,y:5.5,    kind:"medkit", taken:false},
  {x:10.5,y:10.5,  kind:"medkit", taken:false},
  {x:15.5,y:15.5,  kind:"medkit", taken:false},
  {x:12.5,y:13.5,  kind:"core",   taken:false},
];

// salida real del mapa: celda (18,16) es pared tipo 4
const exitCell = {x:18,y:16};

/* ============================
   UTILIDADES
============================ */
function cellBlocked(x,y){
  const c = worldMap[y]?.[x];
  return (c===undefined || c===null || c!==0);
}
function lineOfSight(ax,ay,bx,by){
  const dx=bx-ax, dy=by-ay;
  const dist=Math.hypot(dx,dy);
  const steps = Math.ceil(dist*10);
  for(let i=1;i<=steps;i++){
    const t=i/steps;
    const rx=ax+dx*t;
    const ry=ay+dy*t;
    const mx=Math.floor(rx);
    const my=Math.floor(ry);
    if(cellBlocked(mx,my) && !(mx===Math.floor(bx)&&my===Math.floor(by))){
      return false;
    }
  }
  return true;
}

/* ============================
   PLAYER MOVIMIENTO
============================ */
function tryMove(nx,ny){
  if(!cellBlocked(Math.floor(nx),Math.floor(ny))){
    px=nx;py=ny;
  }
}
function updatePlayer(dt){
  if(keys.left)  pAngle -= rotSpeed*dt;
  if(keys.right) pAngle += rotSpeed*dt;

  const fx=Math.cos(pAngle), fy=Math.sin(pAngle);
  const rx=Math.cos(pAngle+Math.PI/2), ry=Math.sin(pAngle+Math.PI/2);

  let mx=0,my=0;
  if(keys.w){mx+=fx;my+=fy;}
  if(keys.s){mx-=fx;my-=fy;}
  if(keys.a){mx-=rx;my-=ry;}
  if(keys.d){mx+=rx;my+=ry;}

  const L=Math.hypot(mx,my);
  if(L>0){
    mx/=L;my/=L;
    tryMove(px+mx*moveSpeed*dt, py+my*moveSpeed*dt);
  }

  // regen lenta
  if(playerHP>0 && playerHP<playerMaxHP){
    playerHP += regenPerSec*dt;
    if(playerHP>playerMaxHP) playerHP=playerMaxHP;
  }
}

/* ============================
   ENEMIGOS IA
============================ */
const ENEMY = ENEMY_ARCHETYPE;

function updateEnemies(dt){
  for(const e of enemies){
    if(!e.alive) continue;
    const canSee = lineOfSight(e.x,e.y,px,py);

    if(canSee){
      const dx=px-e.x;
      const dy=py-e.y;
      const dist=Math.hypot(dx,dy);
      if(dist>0.1){
        const dirx=dx/dist;
        const diry=dy/dist;
        const step=ENEMY.speed*dt;
        const nx=e.x+dirx*step;
        const ny=e.y+diry*step;
        if(!cellBlocked(Math.floor(nx),Math.floor(ny))){
          e.x=nx;
          e.y=ny;
          e.walkPhase += dt*10;
        }
      }
      if(dist < ENEMY.range){
        playerHP -= ENEMY.dmgPerSec * dt;
        if(playerHP<0) playerHP=0;
      }
    }
  }
}

/* ============================
   RAYCAST
============================ */
function castRay(angle){
  const dirX=Math.cos(angle);
  const dirY=Math.sin(angle);

  let mapX=Math.floor(px);
  let mapY=Math.floor(py);

  const deltaDistX=(dirX===0)?1e30:Math.abs(1/dirX);
  const deltaDistY=(dirY===0)?1e30:Math.abs(1/dirY);

  let stepX,sideDistX;
  let stepY,sideDistY;

  if(dirX<0){stepX=-1;sideDistX=(px-mapX)*deltaDistX;}
  else {stepX=1;sideDistX=(mapX+1.0-px)*deltaDistX;}

  if(dirY<0){stepY=-1;sideDistY=(py-mapY)*deltaDistY;}
  else {stepY=1;sideDistY=(mapY+1.0-py)*deltaDistY;}

  let hit=0;
  let side=0;

  while(hit===0){
    if(sideDistX<sideDistY){
      sideDistX+=deltaDistX;
      mapX+=stepX;
      side=0;
    } else {
      sideDistY+=deltaDistY;
      mapY+=stepY;
      side=1;
    }
    if(mapX<0||mapX>=mapW||mapY<0||mapY>=mapH){hit=1;break;}
    if(worldMap[mapY][mapX]!==0){
      hit=1;
    }
  }

  let dist;
  if(side===0) dist=(sideDistX-deltaDistX);
  else         dist=(sideDistY-deltaDistY);

  const wallType = worldMap[mapY]?.[mapX]||1;

  let wallX;
  if(side===0){ wallX = py + dist*dirY; }
  else        { wallX = px + dist*dirX; }
  wallX -= Math.floor(wallX);

  let texX = Math.floor(wallX*64);
  if(side===0 && dirX>0) texX=64-texX-1;
  if(side===1 && dirY<0) texX=64-texX-1;

  return {dist,side,wallType,texX};
}

let zBuffer = new Array(lowCanvas.width);

/* ============================
   RENDER MUNDO LOW-RES
============================ */
function renderWorld(){
  const w=lowCanvas.width;
  const h=lowCanvas.height;
  const halfH = h/2|0;

  // cielo
  const skyGrad = lowCtx.createLinearGradient(0,0,0,halfH);
  skyGrad.addColorStop(0,"#111122");
  skyGrad.addColorStop(1,"#000000");
  lowCtx.fillStyle=skyGrad;
  lowCtx.fillRect(0,0,w,halfH);

  // piso
  const floorGrad = lowCtx.createLinearGradient(0,halfH,0,h);
  floorGrad.addColorStop(0,"#1a1a1a");
  floorGrad.addColorStop(1,"#000000");
  lowCtx.fillStyle=floorGrad;
  lowCtx.fillRect(0,halfH,w,halfH);

  for(let x=0;x<w;x++){
    const cameraX=(2*x/w -1);
    const rayAngle = pAngle + Math.atan(cameraX*Math.tan(FOV/2));
    const ray = castRay(rayAngle);

    zBuffer[x]=ray.dist;

    const lineH = (h/ray.dist)|0;
    let drawStart=(-lineH/2 + halfH)|0;
    let drawEnd  =( lineH/2 + halfH)|0;
    if(drawStart<0) drawStart=0;
    if(drawEnd>=h)  drawEnd=h-1;

    const tex = wallTextures[ray.wallType]||wallTex1;
    const tctx = tex.getContext('2d');
    const colData = tctx.getImageData(ray.texX,0,1,64).data;

    for(let y=drawStart;y<=drawEnd;y++){
      const dy=y - halfH + lineH/2;
      const ty=((dy/lineH)*64)|0;
      const idx=ty*4;
      let R=colData[idx+0],G=colData[idx+1],B=colData[idx+2];
      if(ray.side===1){R*=0.6;G*=0.6;B*=0.6;}
      const shade=1/(1+ray.dist*0.1);
      R=(R*shade)|0;G=(G*shade)|0;B=(B*shade)|0;
      lowCtx.fillStyle=`rgb(${R},${G},${B})`;
      lowCtx.fillRect(x,y,1,1);
    }
  }
}

/* ============================
   PROYECCI√ìN SPRITES
============================ */
function projectSprite(wx,wy,tw,th){
  const w=lowCanvas.width;
  const h=lowCanvas.height;
  const dx=wx-px, dy=wy-py;
  const dist=Math.hypot(dx,dy);
  const ang=Math.atan2(dy,dx);
  let angDiff=ang-pAngle;
  while(angDiff<-Math.PI) angDiff+=2*Math.PI;
  while(angDiff> Math.PI) angDiff-=2*Math.PI;
  if(Math.abs(angDiff)>FOV) return null;
  if(dist<0.2) return null;
  const screenX=(0.5+(angDiff/FOV))*w;
  const spriteH=(h/dist);
  const spriteW=spriteH*(tw/th);
  return {dist,screenX,spriteW,spriteH,wx,wy};
}

function drawBillboard(tex,proj){
  const w=lowCanvas.width;
  const h=lowCanvas.height;
  const tctx=tex.getContext('2d');
  const tw=tex.width, th=tex.height;
  const imgData=tctx.getImageData(0,0,tw,th).data;

  const startX=(proj.screenX - proj.spriteW/2)|0;
  const endX=(proj.screenX + proj.spriteW/2)|0;

  for(let sx=startX;sx<=endX;sx++){
    if(sx<0||sx>=w) continue;
    if(proj.dist>zBuffer[sx]) continue;

    const u=((sx-(proj.screenX-proj.spriteW/2))/proj.spriteW)*tw;
    const texX=u|0;
    if(texX<0||texX>=tw) continue;

    const startY=((h/2 - proj.spriteH/2))|0;
    const endY=((h/2 + proj.spriteH/2))|0;
    for(let sy=startY;sy<=endY;sy++){
      if(sy<0||sy>=h) continue;
      const v=((sy-(h/2-proj.spriteH/2))/proj.spriteH)*th;
      const texY=v|0;
      if(texY<0||texY>=th) continue;

      const idx=(texY*tw+texX)*4;
      const r=imgData[idx+0],g=imgData[idx+1],b=imgData[idx+2],a=imgData[idx+3];
      if(a<30) continue;
      const shade=1/(1+proj.dist*0.25);
      const R=(r*shade)|0, G=(g*shade)|0, B=(b*shade)|0;
      lowCtx.fillStyle=`rgb(${R},${G},${B})`;
      lowCtx.fillRect(sx,sy,1,1);
    }
  }
}

/* ============================
   RENDER ENEMIGOS / PICKUPS
============================ */
function renderEnemies(dt){
  const toDraw=[];
  for(const e of enemies){
    if(!e.alive) continue;
    const tex = (Math.sin(e.walkPhase*2)>0)
      ? ENEMY.textureWalk
      : ENEMY.textureIdle;
    const proj=projectSprite(e.x,e.y,tex.width,tex.height);
    if(!proj) continue;
    toDraw.push({proj,tex});
  }
  toDraw.sort((A,B)=>B.proj.dist-A.proj.dist);
  for(const obj of toDraw){
    drawBillboard(obj.tex,obj.proj);
  }
}

function renderPickups(){
  const list=[];
  for(const p of pickups){
    if(p.taken) continue;
    const tex=(p.kind==="medkit")?medkitTex:coreTex;
    const proj=projectSprite(p.x,p.y,tex.width,tex.height);
    if(!proj) continue;
    list.push({proj,tex,p});
  }
  list.sort((A,B)=>B.proj.dist-A.proj.dist);

  for(const obj of list){
    const {p,proj,tex}=obj;
    const dist=Math.hypot(p.x-px,p.y-py);
    if(dist<1.0){
      if(p.kind==="medkit"){
        playerHP += 30;
        if(playerHP>playerMaxHP) playerHP=playerMaxHP;
        p.taken=true;
        flashMsg("BOTIQU√çN +30HP");
      } else if(p.kind==="core"){
        hasCore=true;
        p.taken=true;
        missionTextEl.innerHTML =
          "NIVEL 1 ¬∑ Laboratorio Abandonado<br>" +
          "Objetivo: Dir√≠gete a la <b>PUERTA DE EXTRACCI√ìN</b> al sur.";
        flashMsg("N√öCLEO ROJO ADQUIRIDO");
      }
    }
    drawBillboard(tex,proj);
  }
}

/* ============================
   DISPARO
============================ */
function shootEnemy(){
  const aimTolerance=0.05;
  let best=null;
  for(const e of enemies){
    if(!e.alive) continue;
    const dx=e.x-px, dy=e.y-py;
    const ang=Math.atan2(dy,dx);
    let diff=ang-pAngle;
    while(diff<-Math.PI) diff+=2*Math.PI;
    while(diff> Math.PI) diff-=2*Math.PI;
    if(Math.abs(diff)<aimTolerance){
      const d=Math.hypot(dx,dy);
      const ray=castRay(ang);
      if(ray.dist+0.01>=d){
        if(!best||d<best.d) best={e,d};
      }
    }
  }
  if(best){
    best.e.hp-=30;
    flashMsg("IMPACTO");
    if(best.e.hp<=0){
      best.e.alive=false;
      flashMsg("ENEMIGO ABATIDO");
    }
  } else {
    flashMsg("FALLO");
  }
}

/* ============================
   MENSAJES FLASH
============================ */
let msgTimer=0;
let msgText="";
function flashMsg(t){
  msgText=t;
  msgTimer=0.6;
}
function renderGun(dt){
  const w=lowCanvas.width, h=lowCanvas.height;
  const gunW=w*0.3;
  const gunH=h*0.3;
  const x=w*0.5-gunW/2;
  const y=h-gunH;
  const recoil = shooting?2:0;

  lowCtx.fillStyle="#444";
  lowCtx.fillRect(x,y+recoil,gunW,gunH);

  lowCtx.fillStyle="#777";
  lowCtx.fillRect(x+gunW*0.1,y+gunH*0.4+recoil,gunW*0.8,gunH*0.5);

  lowCtx.fillStyle="#222";
  lowCtx.fillRect(x+gunW*0.4,y+gunH*0.1+recoil,gunW*0.2,gunH*0.3);

  if(msgTimer>0){
    lowCtx.font="bold 8px monospace";
    lowCtx.fillStyle="#fff";
    lowCtx.textAlign="center";
    lowCtx.fillText(msgText,w/2,h*0.6);
  }
}
function renderFlash(dt){
  if(msgTimer>0){
    msgTimer-=dt;
    if(msgTimer<0) msgTimer=0;
  }
  if(shootCooldown>0){
    shootCooldown-=dt;
    if(shootCooldown<0) shootCooldown=0;
  }
  // soltamos la anim de disparo
  if(shootCooldown<=0){
    shooting=false;
  }
}

/* ============================
   SALIDA DEL NIVEL
============================ */
function checkExit(){
  const cx=Math.floor(px);
  const cy=Math.floor(py);
  if(cx===exitCell.x && cy===exitCell.y){
    if(hasCore){
      levelFinished=true;
    } else {
      flashMsg("NECESITAS EL N√öCLEO ROJO");
    }
  }
}

/* ============================
   HUD VIDA
============================ */
function updateHUD(){
  const hp=Math.max(0,Math.floor(playerHP));
  const ratio = hp/playerMaxHP;
  const r=(ratio<0.5)?255:Math.floor(255*(1-ratio)*2);
  const g=(ratio>0.5)?255:Math.floor(255*(ratio)*2);
  healthBarFill.style.width = (ratio*100)+"%";
  healthBarFill.style.background =
    `linear-gradient(rgb(${r},${g},0), rgb(${(r*0.6)|0},${(g*0.6)|0},0))`;
  healthText.textContent = `VIDA ${hp}/${playerMaxHP}`;

  if(playerHP<=0){
    centerText.textContent = "HAS MUERTO\nRecarga la p√°gina para reiniciar";
  } else if(levelFinished){
    centerText.textContent = "NIVEL COMPLETADO\n¬°EXFIL EXITOSA!";
  }
}

/* ============================
   MAIN LOOP
============================ */
let lastT = performance.now();
function loop(now){
  const dt=(now-lastT)/1000;
  lastT=now;

  if(playerHP>0 && !levelFinished){
    updatePlayer(dt);
    updateEnemies(dt);

    renderWorld();
    renderEnemies(dt);
    renderPickups();
    renderGun(dt);
    renderFlash(dt);
    checkExit();
  } else {
    // congelar escena
    renderWorld();
    renderEnemies(0);
    renderPickups();
    renderGun(0);
  }

  // escalar low->pantalla
  viewCtx.imageSmoothingEnabled=false;
  viewCtx.clearRect(0,0,viewCanvas.width,viewCanvas.height);
  viewCtx.drawImage(
    lowCanvas,
    0,0,lowCanvas.width,lowCanvas.height,
    0,0,viewCanvas.width,viewCanvas.height
  );

  debugEl.textContent =
    `pos(${px.toFixed(2)},${py.toFixed(2)}) ang:${pAngle.toFixed(2)} `+
    `HP:${playerHP.toFixed(0)} core:${hasCore} `+
    `enemigos:${enemies.filter(e=>e.alive).length} vivos`;

  updateHUD();

  requestAnimationFrame(loop);
}

/* ============================
   START GAME
============================ */
startBtn.addEventListener('click', ()=>{
  startOverlay.style.display='none';
  centerText.textContent="Click para capturar mouse";
  lockPointer();
  // forzamos foco a la ventana para que los eventos WASD entren
  window.focus();
  lastT=performance.now();
  requestAnimationFrame(loop);
});
</script>
</body>
</html>
