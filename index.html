<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>FPS DEMO Optimizado - Laboratorio Nivel 1</title>
<style>
  html, body {
    margin: 0;
    background: #000;
    color: #fff;
    font-family: system-ui, sans-serif;
    overflow: hidden;
  }

  #view {
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    width: 100vw;
    height: 100vh;
    display: block;
    background: #000;
  }

  #ui {
    position: fixed;
    left: 0;
    top: 0;
    width: 100vw;
    color: #fff;
    padding: 8px 12px;
    font-size: 12px;
    line-height: 1.4;
    user-select: none;
    pointer-events: none;
    text-shadow: 0 0 4px #000;
    font-family: monospace;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  #statsRow {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
  }

  #healthBarContainer {
    width: 140px;
    height: 12px;
    background: rgba(0,0,0,0.6);
    border: 1px solid #400;
    border-radius: 3px;
    position: relative;
  }
  #healthBarFill {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    background: linear-gradient(#a00,#600);
    border-radius: 2px;
    width: 100%;
  }
  #healthText {
    font-size: 11px;
    line-height: 1;
    text-shadow: 0 0 4px #000;
    margin-left: 4px;
  }

  #missionText {
    max-width: 400px;
    font-size: 11px;
    line-height: 1.4;
    color: #ccc;
    text-shadow: 0 0 4px #000;
  }

  #debug {
    font-size: 10px;
    color: #666;
  }

  #crosshair {
    position: fixed;
    left: 50%;
    top: 50%;
    width: 16px;
    height: 16px;
    translate: -50% -50%;
    pointer-events: none;
    user-select: none;
  }
  #crosshair:before,
  #crosshair:after {
    content: '';
    position: absolute;
    background: rgba(255,255,255,0.8);
  }
  #crosshair:before {
    left: 50%;
    top: 0;
    width: 2px;
    height: 100%;
    translate: -50% 0;
  }
  #crosshair:after {
    top: 50%;
    left: 0;
    height: 2px;
    width: 100%;
    translate: 0 -50%;
  }

  #centerText {
    position: fixed;
    top: 50%;
    left: 50%;
    translate: -50% -50%;
    color: rgba(255,255,255,0.8);
    font-family: monospace;
    font-size: 14px;
    text-align: center;
    text-shadow: 0 0 4px #000;
    user-select: none;
    pointer-events: none;
    white-space: pre-line;
  }

  #startOverlay {
    position: fixed;
    inset: 0;
    background: radial-gradient(circle at center,
      rgba(0,0,0,0.4) 0%,
      rgba(0,0,0,0.9) 70%);
    display: grid;
    place-items: center;
    color: #fff;
    font-family: system-ui, sans-serif;
    text-align: center;
    padding: 24px;
    cursor: crosshair;
  }

  #startOverlay button {
    background: #8b0000;
    border: 0;
    padding: 12px 20px;
    border-radius: 8px;
    color: #fff;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    box-shadow: 0 10px 30px rgba(255,0,0,0.4);
  }

  #startOverlay button:hover {
    background: #b10000;
  }

  @media (min-width: 768px) {
    .mobile-hint { display: none; }
  }
</style>
</head>
<body>

<!-- Importante: en vez de dibujar en pantalla completa directo,
     usamos un canvas interno low-res y lo pintamos como imagen. -->
<canvas id="internal" width="320" height="180" style="display:none;"></canvas>
<canvas id="view"></canvas>

<div id="ui">
  <div id="statsRow">
    <div style="display:flex;align-items:center;gap:4px;">
      <div id="healthBarContainer"><div id="healthBarFill"></div></div>
      <div id="healthText">VIDA 100/100</div>
    </div>
    <div style="font-size:11px;color:#aaa;text-shadow:0 0 4px #000;">
      WASD moverse · Mouse mirar · Click disparar
    </div>
  </div>

  <div id="missionText">
    NIVEL 1 · Laboratorio Abandonado<br>
    Objetivo: Recupera el <b>NÚCLEO ROJO</b> y llega a la PUERTA DE EXTRACCIÓN.
  </div>

  <div id="debug"></div>
</div>

<div id="crosshair"></div>
<div id="centerText"></div>

<div id="startOverlay">
  <div style="max-width:340px;">
    <h1 style="margin:0 0 12px;font-size:20px;letter-spacing:-0.03em;font-weight:700;font-family:monospace;">
      NIVEL 1: LABORATORIO ABANDONADO
    </h1>
    <p style="margin:0 0 16px;font-size:14px;line-height:1.4;color:#ccc;font-family:monospace;">
      La instalación colapsó tras el experimento del Núcleo Rojo.<br><br>
      Tarea:<br>
      1) Encuentra el Núcleo Rojo.<br>
      2) Sobrevive a la seguridad humana corrompida.<br>
      3) Llega a la puerta de extracción.<br><br>
      Haz click en INICIAR y acepta capturar el mouse.
    </p>
    <button id="startBtn">INICIAR</button>
    <p class="mobile-hint" style="margin-top:12px;color:#f66;font-size:12px;">
      Este demo está pensado para teclado + mouse (PC).
    </p>
  </div>
</div>

<script>
/* =====================================================
   SETUP CANVAS
   - internalCtx = render en baja resolución (320x180)
   - viewCtx = escalado al canvas visible full screen
===================================================== */
const lowCanvas = document.getElementById('internal');
const lowCtx = lowCanvas.getContext('2d');
const viewCanvas = document.getElementById('view');
const viewCtx = viewCanvas.getContext('2d');

function resizeView() {
  viewCanvas.width = window.innerWidth;
  viewCanvas.height = window.innerHeight;
}
resizeView();
window.addEventListener('resize', resizeView);

/* =====================================================
   DOM
===================================================== */
const centerText = document.getElementById('centerText');
const startOverlay = document.getElementById('startOverlay');
const startBtn = document.getElementById('startBtn');
const missionTextEl = document.getElementById('missionText');
const debugEl = document.getElementById('debug');
const healthBarFill = document.getElementById('healthBarFill');
const healthText = document.getElementById('healthText');

let mouseLocked = false;

/* =====================================================
   MUNDO / MAPA
   Paredes con tipos (1,2,3,4) para texturas simples
===================================================== */
const worldMap = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,2,2,2,0,0,0,0,0,0,0,3,3,3,0,0,0,0,1],
  [1,0,2,0,2,0,0,0,0,0,0,0,3,0,3,0,0,0,0,1],
  [1,0,2,2,2,0,0,0,0,0,0,0,3,3,3,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];
const mapW = worldMap[0].length;
const mapH = worldMap.length;

/* =====================================================
   PLAYER
===================================================== */
let px = 2.5;
let py = 2.5;
let pAngle = 0;

const FOV = Math.PI/3;  // 60°
const moveSpeed = 3.0;
const rotSpeed = 2.5;

let playerHP = 100;
const playerMaxHP = 100;
const regenPerSec = 2;

let shooting = false;
let shootCooldown = 0;

let hasCore = false;
let levelFinished = false;

/* =====================================================
   INPUT
===================================================== */
const keys = {w:false,a:false,s:false,d:false,left:false,right:false};

document.addEventListener('keydown', e=>{
  if(e.code==="KeyW") keys.w=true;
  if(e.code==="KeyA") keys.a=true;
  if(e.code==="KeyS") keys.s=true;
  if(e.code==="KeyD") keys.d=true;
  if(e.code==="ArrowLeft") keys.left=true;
  if(e.code==="ArrowRight") keys.right=true;
});
document.addEventListener('keyup', e=>{
  if(e.code==="KeyW") keys.w=false;
  if(e.code==="KeyA") keys.a=false;
  if(e.code==="KeyS") keys.s=false;
  if(e.code==="KeyD") keys.d=false;
  if(e.code==="ArrowLeft") keys.left=false;
  if(e.code==="ArrowRight") keys.right=false;
});

function lockPointer(){
  viewCanvas.requestPointerLock = viewCanvas.requestPointerLock || viewCanvas.mozRequestPointerLock;
  viewCanvas.requestPointerLock();
}
document.addEventListener('pointerlockchange', ()=>{
  mouseLocked = (document.pointerLockElement === viewCanvas);
  centerText.textContent = mouseLocked ? "" : "Click para capturar mouse";
});
document.addEventListener('mousemove', e=>{
  if(mouseLocked){
    const sensitivity = 0.0025;
    pAngle += e.movementX * sensitivity;
  }
});
viewCanvas.addEventListener('mousedown', ()=>{
  if(mouseLocked){
    if(shootCooldown<=0){
      shooting = true;
      shootCooldown = 0.25;
      shootEnemy();
    }
  } else {
    lockPointer();
  }
});

/* =====================================================
   TEXTURAS PARED
===================================================== */
function makeWallTexture(patternFn){
  const c = document.createElement('canvas');
  c.width = 64; c.height = 64;
  const cx = c.getContext('2d');
  const imgData = cx.createImageData(64,64);
  const d = imgData.data;
  for(let y=0;y<64;y++){
    for(let x=0;x<64;x++){
      const idx=(y*64+x)*4;
      const col=patternFn(x,y);
      d[idx+0]=col.r;
      d[idx+1]=col.g;
      d[idx+2]=col.b;
      d[idx+3]=255;
    }
  }
  cx.putImageData(imgData,0,0);
  return c;
}
// rojo metálico
const wallTex1 = makeWallTexture((x,y)=>{
  const stripe=(x%16<2||y%16<2)?80:0;
  return {r:150+stripe,g:20+stripe*0.2,b:20+stripe*0.2};
});
// gris laboratorio
const wallTex2 = makeWallTexture((x,y)=>{
  const grid=((x%8===0)||(y%8===0))?200:140;
  return {r:grid,g:grid,b:grid+10};
});
// tóxico verde
const wallTex3 = makeWallTexture((x,y)=>{
  const noise=((x*y)%13)*10;
  const baseG=180+(noise%40);
  return {r:20,g:baseG,b:20};
});
// puerta salida
const wallTex4 = makeWallTexture((x,y)=>{
  const stripe = (((x+y)%16)<8);
  if(stripe){ return {r:230,g:210,b:40}; }
  return {r:30,g:30,b:30};
});
const wallTextures = {1:wallTex1,2:wallTex2,3:wallTex3,4:wallTex4};

/* =====================================================
   ENEMIGOS HUMANOS
   - sprite con cabeza/brazos/piernas
   - caminan hacia ti si te ven
   - tienen HP
===================================================== */
function makeHumanSprite(baseColorSkin, baseColorSuit){
  const c = document.createElement('canvas');
  c.width=24; c.height=40;
  const cx=c.getContext('2d');

  // piernas
  cx.fillStyle=baseColorSuit;
  cx.fillRect(8,28,8,12); // piernas juntas

  // torso
  cx.fillStyle=baseColorSuit;
  cx.fillRect(4,14,16,16);

  // brazos
  cx.fillStyle=baseColorSkin;
  cx.fillRect(0,16,4,12);  // brazo izq
  cx.fillRect(20,16,4,12); // brazo der

  // cabeza
  cx.fillStyle=baseColorSkin;
  cx.fillRect(7,4,10,10);

  // cara (ojos)
  cx.fillStyle="#000";
  cx.fillRect(9,8,2,2);
  cx.fillRect(13,8,2,2);

  // contorno
  cx.strokeStyle="#000";
  cx.lineWidth=2;
  cx.strokeRect(4,14,16,16);
  cx.strokeRect(7,4,10,10);

  return c;
}

const ENEMY_ARCHETYPE = {
  speed: 1.5,        // m/s
  dmgPerSec: 15,     // daño si está cerca
  range: 1.3,        // distancia para golpear
  maxHP: 60,
  textureIdle: makeHumanSprite("#ffe0c0","#444"),
  textureWalk: makeHumanSprite("#ffe0c0","#666"),
};

// enemigos en el mapa
const enemies = [
  {x:6.5,y:3.5,hp:60,alive:true,walkPhase:0},
  {x:12.5,y:2.5,hp:60,alive:true,walkPhase:0},
  {x:14.5,y:3.5,hp:60,alive:true,walkPhase:0},
  {x:10.5,y:14.5,hp:60,alive:true,walkPhase:0},
  {x:16.5,y:16.0,hp:60,alive:true,walkPhase:0},
];

/* =====================================================
   PICKUPS
===================================================== */
function makeMedkitTexture(){
  const c=document.createElement('canvas');
  c.width=20; c.height=20;
  const cx=c.getContext('2d');
  cx.fillStyle="#fff";
  cx.fillRect(0,0,20,20);
  cx.fillStyle="#c00";
  cx.fillRect(8,2,4,16);
  cx.fillRect(2,8,16,4);
  cx.strokeStyle="#000";
  cx.lineWidth=2;
  cx.strokeRect(0,0,20,20);
  return c;
}
function makeCoreTexture(){
  const c=document.createElement('canvas');
  c.width=20;c.height=20;
  const cx=c.getContext('2d');
  cx.fillStyle="#400";
  cx.fillRect(0,0,20,20);
  cx.fillStyle="#f00";
  cx.beginPath();
  cx.arc(10,10,6,0,Math.PI*2);
  cx.fill();
  cx.strokeStyle="#000";
  cx.lineWidth=2;
  cx.strokeRect(0,0,20,20);
  cx.strokeStyle="#900";
  cx.lineWidth=2;
  cx.stroke();
  return c;
}
const medkitTex = makeMedkitTexture();
const coreTex = makeCoreTexture();

const pickups = [
  {x:4.5,y:5.5, kind:"medkit", taken:false},
  {x:10.5,y:10.5, kind:"medkit", taken:false},
  {x:15.5,y:15.5, kind:"medkit", taken:false},
  {x:12.5,y:13.5, kind:"core", taken:false},
];

const exitCell = {x:18,y:18-2}; // (18,16)

/* =====================================================
   UTILIDADES
===================================================== */
function cellBlocked(x,y){
  const c = worldMap[y]?.[x];
  return (c===undefined || c===null || c!==0);
}
function lineOfSight(ax,ay,bx,by){
  // raycast simple entre A y B
  const dx=bx-ax, dy=by-ay;
  const dist=Math.hypot(dx,dy);
  const steps = Math.ceil(dist*10); // muestras
  for(let i=1;i<=steps;i++){
    const t=i/steps;
    const rx=ax+dx*t;
    const ry=ay+dy*t;
    const mx=Math.floor(rx);
    const my=Math.floor(ry);
    if(cellBlocked(mx,my) && !(mx===Math.floor(bx)&&my===Math.floor(by))){
      return false;
    }
  }
  return true;
}

/* =====================================================
   MOVIMIENTO PLAYER
===================================================== */
function tryMove(nx,ny){
  if(!cellBlocked(Math.floor(nx),Math.floor(ny))){
    px=nx;py=ny;
  }
}
function updatePlayer(dt){
  if(keys.left)  pAngle -= rotSpeed*dt;
  if(keys.right) pAngle += rotSpeed*dt;

  const fx=Math.cos(pAngle), fy=Math.sin(pAngle);
  const rx=Math.cos(pAngle+Math.PI/2), ry=Math.sin(pAngle+Math.PI/2);

  let mx=0,my=0;
  if(keys.w){mx+=fx;my+=fy;}
  if(keys.s){mx-=fx;my-=fy;}
  if(keys.a){mx-=rx;my-=ry;}
  if(keys.d){mx+=rx;my+=ry;}

  const L=Math.hypot(mx,my);
  if(L>0){
    mx/=L;my/=L;
    tryMove(px+mx*moveSpeed*dt, py+my*moveSpeed*dt);
  }

  // regeneración lenta
  if(playerHP>0 && playerHP<playerMaxHP){
    playerHP += regenPerSec*dt;
    if(playerHP>playerMaxHP) playerHP=playerMaxHP;
  }
}

/* =====================================================
   IA ENEMIGOS
   - Si te ven, caminan hacia ti.
   - Golpean si están cerca.
===================================================== */
function updateEnemies(dt){
  for(const e of enemies){
    if(!e.alive) continue;
    // ver jugador
    const canSee = lineOfSight(e.x,e.y,px,py);

    // mover hacia jugador si puede verte
    if(canSee){
      // dirección hacia jugador
      const dx=px-e.x;
      const dy=py-e.y;
      const dist=Math.hypot(dx,dy);
      if(dist>0.1){
        const dirx=dx/dist;
        const diry=dy/dist;
        // intentar mover
        const step = ENEMY_ARCHETYPE.speed*dt;
        const nx = e.x+dirx*step;
        const ny = e.y+diry*step;
        if(!cellBlocked(Math.floor(nx),Math.floor(ny))){
          e.x=nx;
          e.y=ny;
          e.walkPhase += dt*10; // anim caminar
        }
      }

      // daño si muy cerca
      if(dist < ENEMY_ARCHETYPE.range){
        playerHP -= ENEMY_ARCHETYPE.dmgPerSec * dt;
        if(playerHP<0) playerHP=0;
      }
    }
  }
}

/* =====================================================
   RAYCAST + RENDER 3D EN LOW-RES
===================================================== */
function castRay(rayAngle){
  const dirX=Math.cos(rayAngle);
  const dirY=Math.sin(rayAngle);
  let mapX=Math.floor(px);
  let mapY=Math.floor(py);

  const deltaDistX=(dirX===0)?1e30:Math.abs(1/dirX);
  const deltaDistY=(dirY===0)?1e30:Math.abs(1/dirY);

  let stepX,sideDistX;
  let stepY,sideDistY;

  if(dirX<0){stepX=-1;sideDistX=(px-mapX)*deltaDistX;}
  else{stepX=1;sideDistX=(mapX+1.0-px)*deltaDistX;}

  if(dirY<0){stepY=-1;sideDistY=(py-mapY)*deltaDistY;}
  else{stepY=1;sideDistY=(mapY+1.0-py)*deltaDistY;}

  let hit=0;
  let side=0;

  while(hit===0){
    if(sideDistX<sideDistY){
      sideDistX+=deltaDistX;
      mapX+=stepX;
      side=0;
    } else {
      sideDistY+=deltaDistY;
      mapY+=stepY;
      side=1;
    }
    if(mapX<0||mapX>=mapW||mapY<0||mapY>=mapH){hit=1;break;}
    if(worldMap[mapY][mapX]!==0){
      hit=1;
    }
  }

  let dist;
  if(side===0) dist=(sideDistX-deltaDistX); else dist=(sideDistY-deltaDistY);

  let wallType = worldMap[mapY]?.[mapX]||1;

  // tex coord en X
  let wallX;
  if(side===0){ wallX = py + dist*dirY; }
  else{ wallX = px + dist*dirX; }
  wallX -= Math.floor(wallX);

  let texX = Math.floor(wallX*64);
  if(side===0 && dirX>0) texX=64-texX-1;
  if(side===1 && dirY<0) texX=64-texX-1;

  return {dist,side,wallType,texX};
}

let zBuffer = new Array(lowCanvas.width);

function renderWorld(){
  const w = lowCanvas.width;
  const h = lowCanvas.height;
  const halfH = h/2|0;

  // cielo
  const skyGrad = lowCtx.createLinearGradient(0,0,0,halfH);
  skyGrad.addColorStop(0,"#111122");
  skyGrad.addColorStop(1,"#000000");
  lowCtx.fillStyle=skyGrad;
  lowCtx.fillRect(0,0,w,halfH);

  // piso
  const floorGrad = lowCtx.createLinearGradient(0,halfH,0,h);
  floorGrad.addColorStop(0,"#1a1a1a");
  floorGrad.addColorStop(1,"#000000");
  lowCtx.fillStyle=floorGrad;
  lowCtx.fillRect(0,halfH,w,halfH);

  for(let x=0;x<w;x++){
    const cameraX = (2*x/w -1);
    const rayAngle = pAngle + Math.atan(cameraX*Math.tan(FOV/2));
    const ray = castRay(rayAngle);

    zBuffer[x]=ray.dist;

    const lineH = (h/ray.dist)|0;
    let drawStart = (-lineH/2 + halfH)|0;
    let drawEnd   = ( lineH/2 + halfH)|0;
    if(drawStart<0) drawStart=0;
    if(drawEnd>=h) drawEnd=h-1;

    const tex = wallTextures[ray.wallType]||wallTex1;
    const tctx = tex.getContext('2d');
    const colData = tctx.getImageData(ray.texX,0,1,64).data;

    for(let y=drawStart;y<=drawEnd;y++){
      const dy = y - halfH + lineH/2;
      const ty = ( (dy/lineH)*64 )|0;
      const idx = ty*4;
      let R=colData[idx+0],
          G=colData[idx+1],
          B=colData[idx+2];
      if(ray.side===1){R*=0.6;G*=0.6;B*=0.6;}
      const shade = 1/(1+ray.dist*0.1);
      R=(R*shade)|0;G=(G*shade)|0;B=(B*shade)|0;
      lowCtx.fillStyle=`rgb(${R},${G},${B})`;
      lowCtx.fillRect(x,y,1,1);
    }
  }
}

/* =====================================================
   PROYECCIÓN SPRITES (enemigos y pickups)
===================================================== */
function projectSprite(wx,wy,tw,th){
  const w = lowCanvas.width;
  const h = lowCanvas.height;
  const dx=wx-px, dy=wy-py;
  const dist=Math.hypot(dx,dy);
  const ang=Math.atan2(dy,dx);
  let angDiff=ang-pAngle;
  while(angDiff<-Math.PI) angDiff+=2*Math.PI;
  while(angDiff> Math.PI) angDiff-=2*Math.PI;
  if(Math.abs(angDiff)>FOV) return null;
  if(dist<0.2) return null;
  const screenX=(0.5+(angDiff/FOV))*w;
  const spriteH=(h/dist);
  const spriteW=spriteH*(tw/th);
  return {dist,screenX,spriteW,spriteH,ang,wx,wy};
}

function drawBillboard(tex,proj){
  const w = lowCanvas.width;
  const h = lowCanvas.height;
  const tctx = tex.getContext('2d');
  const tw=tex.width, th=tex.height;
  const imgData = tctx.getImageData(0,0,tw,th).data;

  const startX=(proj.screenX - proj.spriteW/2)|0;
  const endX=(proj.screenX + proj.spriteW/2)|0;

  for(let sx=startX; sx<=endX; sx++){
    if(sx<0||sx>=w) continue;
    // zBuffer: si está detrás de pared, no se ve
    if(proj.dist>zBuffer[sx]) continue;

    const u = ( (sx - (proj.screenX-proj.spriteW/2))/proj.spriteW )*tw;
    const texX = u|0;
    if(texX<0||texX>=tw) continue;

    const startY = ( (h/2 - proj.spriteH/2) )|0;
    const endY = ( (h/2 + proj.spriteH/2) )|0;
    for(let sy=startY; sy<=endY; sy++){
      if(sy<0||sy>=h) continue;
      const v = ( (sy - (h/2 - proj.spriteH/2))/proj.spriteH )*th;
      const texY = v|0;
      if(texY<0||texY>=th) continue;

      const idx=(texY*tw+texX)*4;
      const r=imgData[idx+0],
            g=imgData[idx+1],
            b=imgData[idx+2],
            a=imgData[idx+3];
      if(a<30) continue;

      const shade = 1/(1+proj.dist*0.25);
      const R=(r*shade)|0;
      const G=(g*shade)|0;
      const B=(b*shade)|0;

      lowCtx.fillStyle=`rgb(${R},${G},${B})`;
      lowCtx.fillRect(sx,sy,1,1);
    }
  }
}

/* =====================================================
   RENDER ENEMIGOS / PICKUPS
===================================================== */
function renderEnemies(dt){
  // ordenar por distancia desc (para pintar cerca encima de lejos)
  const list = [];
  for(const e of enemies){
    if(!e.alive) continue;
    const tex = (Math.sin(e.walkPhase*2)>0)?ENEMY_ARCHETYPE.textureWalk:ENEMY_ARCHETYPE.textureIdle;
    const proj = projectSprite(e.x,e.y,tex.width,tex.height);
    if(!proj) continue;

    // si hay muro entre enemigo y player, igual lo dibujamos (porque igual puede estar detrás pared en visión del player),
    // pero para IA usamos lineOfSight; para daño ya lo controlamos ahí
    list.push({proj,tex});
  }
  list.sort((A,B)=>B.proj.dist-A.proj.dist);
  for(const obj of list){
    drawBillboard(obj.tex,obj.proj);
  }
}

function renderPickups(){
  const list=[];
  for(const p of pickups){
    if(p.taken) continue;
    const tex = (p.kind==="medkit")?medkitTex:coreTex;
    const proj=projectSprite(p.x,p.y,tex.width,tex.height);
    if(!proj) continue;
    list.push({proj,tex,p});
  }
  list.sort((A,B)=>B.proj.dist-A.proj.dist);

  for(const obj of list){
    const {p,proj,tex}=obj;

    // pickup si muy cerca
    const dist=Math.hypot(p.x-px,p.y-py);
    if(dist<1.0){
      if(p.kind==="medkit"){
        playerHP += 30;
        if(playerHP>playerMaxHP) playerHP=playerMaxHP;
        p.taken=true;
        flashMsg("BOTIQUÍN +30HP");
      } else if(p.kind==="core"){
        hasCore=true;
        p.taken=true;
        missionTextEl.innerHTML =
          "NIVEL 1 · Laboratorio Abandonado<br>" +
          "Objetivo: Dirígete a la <b>PUERTA DE EXTRACCIÓN</b> al sur.";
        flashMsg("NÚCLEO ROJO ADQUIRIDO");
      }
    }

    drawBillboard(tex,proj);
  }
}

/* =====================================================
   DISPARO
   - Busca enemigo alineado con la mira
   - Aplica daño (ya no muere de 1 tiro)
===================================================== */
function shootEnemy(){
  const aimTolerance = 0.05;
  let best=null;
  for(const e of enemies){
    if(!e.alive) continue;
    const dx=e.x-px, dy=e.y-py;
    const ang=Math.atan2(dy,dx);
    let diff=ang-pAngle;
    while(diff<-Math.PI) diff+=2*Math.PI;
    while(diff> Math.PI) diff-=2*Math.PI;
    if(Math.abs(diff)<aimTolerance){
      const d=Math.hypot(dx,dy);
      const ray=castRay(ang);
      if(ray.dist+0.01>=d){
        if(!best||d<best.d) best={e,d};
      }
    }
  }
  if(best){
    best.e.hp-=30;
    flashMsg("IMPACTO");
    if(best.e.hp<=0){
      best.e.alive=false;
      flashMsg("ENEMIGO ABATIDO");
    }
  } else {
    flashMsg("FALLO");
  }
}

/* =====================================================
   FLASH / HUD MESSAGES
===================================================== */
let msgTimer=0;
let msgText="";
function flashMsg(t){
  msgText=t;
  msgTimer=0.6;
}

function renderGun(dt){
  // arma en lowres: un bloque gris abajo
  const w=lowCanvas.width, h=lowCanvas.height;
  const gunW=w*0.3;
  const gunH=h*0.3;
  const x=w*0.5-gunW/2;
  const y=h-gunH;
  const recoil = shooting?2:0;

  lowCtx.fillStyle="#444";
  lowCtx.fillRect(x,y+recoil,gunW,gunH);

  lowCtx.fillStyle="#777";
  lowCtx.fillRect(x+gunW*0.1,y+gunH*0.4+recoil,gunW*0.8,gunH*0.5);

  lowCtx.fillStyle="#222";
  lowCtx.fillRect(x+gunW*0.4,y+gunH*0.1+recoil,gunW*0.2,gunH*0.3);

  if(msgTimer>0){
    lowCtx.font="bold 8px monospace";
    lowCtx.fillStyle="#fff";
    lowCtx.textAlign="center";
    lowCtx.fillText(msgText,w/2,h*0.6);
  }
}

function renderFlash(dt){
  if(msgTimer>0){
    msgTimer-=dt;
    if(msgTimer<0) msgTimer=0;
  }
  if(shootCooldown>0){
    shooting=false;
  }
}

/* =====================================================
   SALIDA DEL NIVEL
===================================================== */
function checkExit(){
  const cx=Math.floor(px);
  const cy=Math.floor(py);
  if(cx===exitCell.x && cy===exitCell.y){
    if(hasCore){
      levelFinished=true;
    } else {
      flashMsg("NECESITAS EL NÚCLEO ROJO");
    }
  }
}

/* =====================================================
   HUD VIDA / ESTADO
===================================================== */
function updateHUD(){
  const hp=Math.max(0,Math.floor(playerHP));
  const ratio = hp/playerMaxHP;
  const r=(ratio<0.5)?255:Math.floor(255*(1-ratio)*2);
  const g=(ratio>0.5)?255:Math.floor(255*(ratio)*2);
  healthBarFill.style.width = (ratio*100)+"%";
  healthBarFill.style.background =
    `linear-gradient(rgb(${r},${g},0), rgb(${(r*0.6)|0},${(g*0.6)|0},0))`;
  healthText.textContent = `VIDA ${hp}/${playerMaxHP}`;

  if(playerHP<=0){
    centerText.textContent = "HAS MUERTO\nRecarga la página para reiniciar";
  } else if(levelFinished){
    centerText.textContent = "NIVEL COMPLETADO\n¡EXFIL EXITOSA!";
  }
}

/* =====================================================
   LOOP
===================================================== */
let lastT = performance.now();
function loop(now){
  const dt=(now-lastT)/1000;
  lastT=now;

  if(playerHP>0 && !levelFinished){
    updatePlayer(dt);
    updateEnemies(dt);

    if(shootCooldown>0){
      shootCooldown-=dt;
      if(shootCooldown<0) shootCooldown=0;
    }

    // dibujar mundo low-res
    renderWorld();
    renderEnemies(dt);
    renderPickups();
    renderGun(dt);
    renderFlash(dt);
    checkExit();
  } else {
    // congelado pero dibujamos escena final
    renderWorld();
    renderEnemies(0);
    renderPickups();
    renderGun(0);
  }

  // escalar lowCanvas -> viewCanvas
  viewCtx.imageSmoothingEnabled = false;
  viewCtx.clearRect(0,0,viewCanvas.width,viewCanvas.height);
  viewCtx.drawImage(
    lowCanvas,
    0,0,lowCanvas.width,lowCanvas.height,
    0,0,viewCanvas.width,viewCanvas.height
  );

  debugEl.textContent =
    `pos(${px.toFixed(2)},${py.toFixed(2)}) ang:${pAngle.toFixed(2)} `+
    `HP:${playerHP.toFixed(0)} core:${hasCore} `+
    `enemigos:${enemies.filter(e=>e.alive).length} vivos`;

  updateHUD();
  requestAnimationFrame(loop);
}

/* =====================================================
   START
===================================================== */
startBtn.addEventListener('click', ()=>{
  startOverlay.style.display='none';
  centerText.textContent="Click para capturar mouse";
  lockPointer();
  lastT=performance.now();
  requestAnimationFrame(loop);
});
</script>
</body>
</html>
